package polinimio;

public class Polinomio {

	private int grado;
	private double[] coeficiente;

	//La posicion 0 del arreglo de coeficientes con tiene el coeficiente
	//	de grado n y la posicion n con tiene al termino independiente.

	public int getGrado() {
		return grado;
	}
	public void setGrado(int grado) {
		this.grado = grado;
	}

	public double[] getCoeficiente() {
		return coeficiente;
	}

	public double getCoorCoeficiente(int i) {
		return coeficiente[i];
	}

	public void setCoeficiente(double[] coeficiente) {
		this.coeficiente = coeficiente;
	}

	public Polinomio(){ 
		this.setCoeficiente(null);
		this.setGrado(0);
	}

	public Polinomio(double[] coeficiente, int grado){ 
		this.setCoeficiente(coeficiente);
		this.setGrado(grado);
	}

	public double potencia(double x, int grado ){
		if( grado == 1)
		{
			return x;
		}
		return 	x*potencia(x,grado-1);			
	}


	public double evaluarMSucesivas(double x ){
		double resultado = 0;
		double potencia;
		for( int i = 0; i < this.getGrado() ; i++ )
		{
			potencia = 1;
			for( int j = i; j <this.getGrado() ; j++){
				potencia *= x;
			}
			//	System.out.println("Sucesiva: "+x+"^"+(this.getGrado()-i)+" = "+aux);
			resultado += this.getCoorCoeficiente( i )*potencia;
		}
		resultado += this.getCoorCoeficiente( this.getGrado() );
		return resultado;
	}

	//Sin considerar exponente par	
	public double evaluarRecursiva(double x ) { 
		double resultado = 0;
		double potencia;

		for( int i = 0; i < this.getGrado() ; i++ )
		{
			potencia = potencia( x,this.getGrado()-i);
			//	System.out.println("Recursiva"+x+"^"+(this.getGrado()-i)+" = "+aux);
			resultado += this.getCoorCoeficiente( i )*potencia;
		}

		resultado += this.getCoorCoeficiente( this.getGrado() );
		return resultado;
	}

	//Considerando exponente par o inpar
	public double evaluarRecursivaPar(double x ) {
		double resultado = 0;
		double potencia;
		int n;
		for( int i = 0; i < this.getGrado() ; i++ )
		{	
			n = this.getGrado() - i ;

			if( ( (n) % 2) != 0) 		//si es impar 
				potencia = potencia( x, n );
			else 						// si es par.
				potencia = potencia( x*x,( n )/2);
			
			//	System.out.println("Recursiva"+x+"^"+(this.getGrado()-i)+" = "+aux);
			resultado += this.getCoorCoeficiente( i )*potencia;
		}

		resultado += this.getCoorCoeficiente( this.getGrado() );
		return resultado;
	}
	
	// La programacion Dinamica consiste en reutilizar lo ya calculado. 
	public double evaluarProgDinamica(double x ) {
		double resultado = 0;
		double potencia = 1; // este es el x elevado a la potencia, en la primera es 1 porque x^0 = 1;
		
		for( int i = this.getGrado(); i >= 0  ; i-- )
		{	
			resultado += this.getCoorCoeficiente( i )*potencia;
			potencia *= x; // Aca incremento el exponente en 1.
		}
		return resultado;
	}

	// FALTA MEJORAR, creo que deberia ser igual que la que hice antes pero que tarde menos,
	// la cosa que no me doy cuenta que puedo optimizar sin cambiar el algoritmo.
	public double evaluarMejorada(double x ) {
		double resultado = 0;
		double potencia;
		for( int i = 0; i < this.getGrado() ; i++ )
		{
			potencia = 1;
			for( int j = i; j <this.getGrado() ; j++){
				potencia *= x;
			}
			//System.out.println("SucesivaMejorada: "+x+"^"+(this.getGrado()-i)+" = "+aux);
			resultado += this.getCoorCoeficiente( i )*potencia;
		}

		resultado += this.getCoorCoeficiente( this.getGrado() );
		return resultado;
	}

	public double evaluarPow (double x ) {
		double resultado = 0;
		for( int i = 0; i < this.getGrado() ; i++ )
		{
			//System.out.println("Math.Pow: "+x+"^"+(this.getGrado()-i)+" = " + Math.pow(x,(this.getGrado()-i)) );
			resultado += this.getCoorCoeficiente( i ) * Math.pow(x, (this.getGrado()-i) );
		}
		resultado += this.getCoorCoeficiente( this.getGrado() );
		return resultado;
	}

}
